namespace cuda {

   __global__ void initSpace( long int N , long int n, double* x, double EPS, double* space) {
      int i = blockDim.x * blockIdx.x + threadIdx.x;
      int j = blockDim.y * blockIdx.y + threadIdx.y + n;
      if (i < N) {
         space[j * N + i] = x[i] + EPS;
      }
   };

   __global__ void bulkGrad( long int N , long int n,  double EPS, double * space, double * grad) {
      int i = blockDim.x * blockIdx.x + threadIdx.x + n;
      double val = 0.0;

      if (i < N) {
         space[i * N + i] -= EPS;
         FUNCTION(N, &space[i * N], &val);

         space[i * N + i] += 2.0 * EPS;
         val = val * -1.0;
         FUNCTION(N, &space[i * N], &val);

         grad[i] = val / (2.0 * EPS);

         space[i * N + i] -= 2.0 * EPS; // Reset space back to normal
      }
   };

   inline void linalg_grad( long int N , double EPS, vector<double> & x,  vector<double>& grad, double * _space) {

      int TPB_OPTIMAL_1D = 256;
      int TPB_OPTIMAL_2D = 16;
      long int UNIT_OP = N / (16384 / sizeof(double));

      cout << UNIT_OP;

      double* _grad = (double*)cuda::alloc(grad);
      double* _x = (double*)cuda::alloc(x);

      dim3 GPU_TPB_1D (TPB_OPTIMAL_1D);
      dim3 GPU_BLOCK_1D(_GLB_N_ / GPU_TPB_1D.x / UNIT_OP);

      cout << "GPU_TPB_1D : " << GPU_TPB_1D.x << "\n";
      cout << "GPU_BLOCK_1D : " << GPU_BLOCK_1D.x << "\n";

      dim3 GPU_TPB_2D(TPB_OPTIMAL_2D, TPB_OPTIMAL_2D);
      dim3 GPU_BLOCK_2D(_GLB_N_ / GPU_TPB_2D.x / UNIT_OP , _GLB_N_ / GPU_TPB_2D.y / UNIT_OP);

      cout << "GPU_TPB_2D : " << GPU_TPB_2D.x << " | " << GPU_TPB_2D.y << "\n";
      cout << "GPU_BLOCK_2D : " << GPU_BLOCK_2D.x << " | " << GPU_BLOCK_2D.y << "\n";


      for (int ni = 0; ni < N; ni += UNIT_OP) {
         initSpace <<<GPU_BLOCK_2D , GPU_TPB_2D>>> (N, ni, _x , EPS , _space);
         bulkGrad  <<<GPU_BLOCK_1D , GPU_TPB_1D>>> (N, ni, EPS, _space, &_grad[ni]);
         cuda::unalloc(&_grad[ni], grad[ni]);
      }
      cuda::unalloc(_x);
   };
};

